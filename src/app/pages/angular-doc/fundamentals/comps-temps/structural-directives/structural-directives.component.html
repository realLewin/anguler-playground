<!-- Structural directives are responsible for HTML layout. They shape or reshape the DOM's 
     structure, typically by adding, removing, or manipulating elements. -->
<!-- You'll learn in this guide that the asterisk (*) is a convenience notation and the string 
     is a microsyntax rather than the usual template expression. Angular desugars this notation 
     into a marked-up <ng-template> that surrounds the host element and its descendents. -->
<!-- A directive class is spelled in UpperCamelCase (NgIf). A directive's attribute name is 
     spelled in lowerCamelCase (ngIf). -->
<!-- You can apply many attribute directives to one host element. You can only apply one 
     structural directive to a host element. -->
<div>
  <!--------- Three of the common, built-in structural directives—NgIf, NgFor, and NgSwitch --------->
  <div>
    <!-- The ngIf directive doesn't hide elements with CSS. It adds and removes them 
         physically from the DOM. -->
    <p *ngIf="singleItem">this paragraph is generated by ngIf</p>
    <p *ngFor="let item of multiItems">
      this is generated by ngFor with {{ item }}
    </p>
    <div [ngSwitch]="switchItem">
      <p *ngSwitchCase="'one'">this is generated by ngSwitch with 'one'</p>
      <p *ngSwitchCase="'two'">this is generated by ngSwitch with 'two'</p>
      <p *ngSwitchDefault>this is generated by ngSwitch with default</p>
    </div>
  </div>
  <!----------------------------------- the asterisk(*) prefix -------------------------------------->
  <div>
    <!-- Angular translates the *ngIf attribute into a <ng-template> element, wrapped around the host 
         element, like this. -->
    <!-- Angular consumed the <ng-template> content during its actual rendering and replaced the 
         <ng-template> with a diagnostic comment. -->
    <!-- The NgFor and NgSwitch... directives follow the same pattern. -->
    <ng-template [ngIf]="singleItem">
      <p>this is paragraph with ng-tremplate</p>
    </ng-template>
  </div>
  <!---------------------------------------inside *ngFor -------------------------------------------->
  <div>
    <!-- Here's a full-featured application of NgFor, written both ways: -->
    <div
      *ngFor="
        let hero of heroes;
        let i = index;
        first as isFirst;
        let odd = odd;
        trackBy: trackById
      "
      [class.odd]="odd"
    >
      <p *ngIf="isFirst">{{ hero.name }} is your first HERO!</p>
      Your {{ hero.id }} is: {{ hero.name }}
    </div>
    <!-- same result: -->
    <!-- Everything outside the ngFor string stays with the host element -->
    <ng-template
      ngFor
      let-hero
      [ngForOf]="heroes"
      let-i="index"
      let-odd="odd"
      [ngForTrackBy]="trackById"
    >
      <div [class.odd]="odd">({{ i }}) {{ hero.name }}</div>
    </ng-template>
  </div>
  <!--------------------------------------- microsyntax --------------------------------------------->
  <div>
    <div>
      <!-- The Angular microsyntax lets you configure a directive in a compact, friendly string. 
           The microsyntax parser translates that string into attributes on the <ng-template>: -->
      <!-- The let keyword declares a template input variable that you reference within the template.
           The parser translates let hero, let i, and let odd into variables named let-hero, 
           let-i, and let-odd. -->
      <!-- The microsyntax parser title-cases all directives and prefixes them with the directive's 
           attribute name, such as ngFor. For example, the ngFor input properties, of and trackBy, 
           become ngForOf and ngForTrackBy, -->
      <!-- As the NgFor directive loops through the list, it sets and resets properties of its 
           own context object. These properties can include, but aren't limited to, index, odd, 
           and a special property named $implicit. -->
      <!-- The let-i and let-odd variables were defined as let i=index and let odd=odd. Angular 
           sets them to the current value of the context's index and odd properties. -->
      <!-- The context property for let-hero wasn't specified. Its intended source is implicit. 
           Angular sets let-hero to the value of the context's $implicit property, which NgFor 
           has initialized with the hero for the current iteration. -->
    </div>
    <div>
      <!---------write your own structural directives: -->
      <!-- These microsyntax mechanisms are also available to you when you write your own 
           structural directives. -->
      <!-- Constraints:
           1.It must be known ahead of time so that IDEs can parse it without knowing the underlying 
             semantics of the directive or what directives are present. 
           2.It must translate to key-value attributes in the DOM.-->
      <!-- Grammar: 
           When you write your own structural directives, use the following grammar:
           *:prefix="( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*"-->
    </div>
  </div>
  <!------------------------------------template input variable ------------------------------------->
  <div>
    <!-- A template input variable is a variable whose value you can reference within a single 
         instance of the template. There are several such variables in this example: hero, i, and odd. 
         All are preceded by the keyword let. -->
  </div>
  <!----------------------------- One structural directive per host element ------------------------->
  <div>
    <!-- Someday you'll want to repeat a block of HTML but only when a particular condition is true. 
         You'll try to put both an *ngFor and an *ngIf on the same host element. Angular won't let you. 
         You may apply only one structural directive to an element. -->
    <!-- There's an easy solution for this use case: put the *ngIf on a container element that wraps 
         the *ngFor element. One or both elements can be an ng-container so you don't have to introduce 
         extra levels of HTML. -->
  </div>
  <!------------------------------------- inside ngSwitch directives -------------------------------->
  <div>
    <!-- NgSwitch itself is not a structural directive. It's an attribute directive that controls 
         the behavior of the other two switch directives. That's why you write [ngSwitch], never 
         *ngSwitch. -->
    <!-- NgSwitchCase and NgSwitchDefault are structural directives. -->
    <!-- As with other structural directives, the NgSwitchCase and NgSwitchDefault can be desugared 
         into the <ng-template> element form. -->
  </div>
  <!------------------------------------prefer the saterisk(*) syntax ------------------------------->
  <div>
    <!-- The asterisk (*) syntax is more clear than the desugared form. Use <ng-container> when 
         there's no single element to host the directive. -->
    <!-- While there's rarely a good reason to apply a structural directive in template attribute 
         or element form, it's still important to know that Angular creates a <ng-template> and to 
         understand how it works. You'll refer to the <ng-template> when you write your own 
         structural directive. -->
  </div>
  <!----------------------------------------the <ng-template> --------------------------------------->
  <div>
    <!-- The <ng-template> is an Angular element for rendering HTML. It is never displayed directly. 
         In fact, before rendering the view, Angular replaces the <ng-template> and its contents with 
         a comment. -->
    <!-- If there is no structural directive and you merely wrap some elements in a <ng-template>, 
         those elements disappear. -->
    <p>hi</p>
    <ng-template><p>hello</p></ng-template>
    <p>why no answer?</p>
  </div>
  <!----------------------------- group sibling element with <ng-container> ------------------------->
  <div>
    <!-- Introducing another container element—typically a <span> or <div>—to group the elements under 
         a single root is usually harmless. Usually ... but not always. The grouping element may break 
         the template appearance because CSS styles neither expect nor accommodate the new layout. 
         refer to doc for more... -->
    <!-- Another problem: some HTML elements require all immediate children to be of a specific type. 
         For example, the <select> element requires <option> children. You can't wrap the options in 
         a conditional <div> or a <span>. The browser won't display an <option> within a <span>.
         refer to doc for more... -->
    <div>
      <!-- The Angular <ng-container> is a grouping element that doesn't interfere with styles or layout 
           because Angular doesn't put it in the DOM. -->
      <!-- The <ng-container> is a syntax element recognized by the Angular parser. It's not a directive,
           component, class, or interface. It's more like the curly braces in a JavaScript if-block: 
           Without those braces, JavaScript would only execute the first statement when you intend to 
           conditionally execute all of them as a single block. The <ng-container> satisfies a similar 
           need in Angular templates.-->
    </div>
  </div>
  <!-----------------------------------write a strutural directive ---------------------------------->
  <div>
    <!-- In this section, you write an UnlessDirective structural directive that does the 
         opposite of NgIf. -->
    <p>Your condition is: {{ condition }}</p>
    <button mat-stroked-button (click)="toggleCondition()">
      toggle condition
    </button>
    <p *appUnless="condition">this shows because condition is false</p>
    <p *appUnless="!condition">this shows because condition is true</p>
  </div>
  <!---------------------- Improving template type checking for custom directives ------------------->
  <div>
    <!-- Use the type-guard properties to inform the template type checker of an expected type, 
         thus improving compile-time type-checking for that template.
         A property ngTemplateGuard_(someInputProperty) lets you specify a more accurate type for 
         an input expression within the template.
         The ngTemplateContextGuard static property declares the type of the template context. -->
    <!-- For more information, see Template type checking guide. -->
  </div>
</div>
